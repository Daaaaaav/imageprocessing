import cv2
import numpy as np
from scipy.fftpack import dct, idct

def greyscale(img):
    return cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

def negative(img):
    return cv2.bitwise_not(img)

def flip(img, direction):
    return cv2.flip(img, direction)

def brightness(img, value):
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    hsv[:, :, 2] = cv2.add(hsv[:, :, 2], value)
    return cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

def contrast(img, alpha):
    return cv2.convertScaleAbs(img, alpha=alpha, beta=0)

def rotate(img, angle):
    (h, w) = img.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    return cv2.warpAffine(img, M, (w, h))

def scale(img, fx, fy):
    return cv2.resize(img, None, fx=fx, fy=fy)

def translation(img, tx, ty):
    M = np.float32([[1, 0, tx], [0, 1, ty]])
    return cv2.warpAffine(img, M, (img.shape[1], img.shape[0]))

def sepia_filter(img):
    kernel = np.array([[0.272, 0.534, 0.131],
                       [0.349, 0.686, 0.168],
                       [0.393, 0.769, 0.189]])
    return cv2.transform(img, kernel)

def cyano_filter(img):
    kernel = np.array([[0.272, 0.534, 0.131],
                       [0.349, 0.686, 0.168],
                       [0.393, 0.769, 0.189]])
    return cv2.transform(img, kernel)

def custom_filter(img, kernel):
    return cv2.filter2D(img, -1, kernel)

def fourier_transform(img):
    dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)
    dft_shift = np.fft.fftshift(dft)
    magnitude_spectrum = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]))
    return magnitude_spectrum

def mean_filter(img, ksize):
    return cv2.blur(img, (ksize, ksize))

def gaussian_filter(img, ksize):
    return cv2.GaussianBlur(img, (ksize, ksize), 0)

def median_filter(img, ksize):
    return cv2.medianBlur(img, ksize)

def sobel_filter(img, dx, dy, ksize):
    return cv2.Sobel(img, cv2.CV_64F, dx, dy, ksize)

def canny_edge(img, threshold1, threshold2):
    return cv2.Canny(img, threshold1, threshold2)

def laplacian_filter(img):
    return cv2.Laplacian(img, cv2.CV_64F)

def dct_compression(img):
    img = np.float32(img) / 255.0
    img_dct = dct(dct(img.T, norm='ortho').T, norm='ortho')
    return np.uint8(img_dct * 255)

def global_thresholding(img, threshold):
    _, thresh_img = cv2.threshold(img, threshold, 255, cv2.THRESH_BINARY)
    return thresh_img

def adaptive_thresholding(img, method, block_size, C):
    if method == 'mean':
        return cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size, C)
    elif method == 'gaussian':
        return cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, C)

def k_means_clustering(img, K):
    Z = img.reshape((-1, 3))
    Z = np.float32(Z)
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
    _, labels, centers = cv2.kmeans(Z, K, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
    centers = np.uint8(centers)
    res = centers[labels.flatten()]
    return res.reshape((img.shape))

def morphological(img, operation, kernel):
    return cv2.morphologyEx(img, operation, kernel)

def boundary_extraction(img):
    kernel = np.ones((3, 3), np.uint8)
    erosion = cv2.erode(img, kernel, iterations=1)
    return img - erosion

def noise_reduction(img):
    return cv2.fastNlMeansDenoisingColored(img, None, 10, 10, 7, 21)